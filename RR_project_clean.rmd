---
title: "Vehicle Loan Default Prediction"
author: "Agata Tomaszewska, Joanna Misiak, Ilya Kidyshka"
output:
  html_document: default
  pdf_document: default
  word_document: default
date: "2025-06-02"
editor_options: 
  markdown: 
    wrap: 72
---

## Project description

This project explores the prediction of loan default status using a
machine learning classification approach. The notebook includes data
preprocessing, exploratory data analysis, feature engineering, and the
application of classification algorithms such as Logistic Regression and
Random Forest. The goal is to accurately classify whether a loan
applicant is likely to default, leveraging real-world financial data and
evaluating model performance through metrics like accuracy and confusion
matrix. The project provides insights into important predictive features
and demonstrates a practical workflow for tackling binary classification
problems in the financial domain.

## Table of contents

1.  [Data loading]
2.  [Preliminary Data Analysis]
3.  [Explanatory Data Analysis]
    -   [Class distribution]
    -   [Default vs. Disbursal date]
    -   [Outlier Treatment]
    -   [Univariate analysis]
    -   [Feature Selection]
        -   [Standardization of data]
        -   [Dummy insertion]
4.  [Modeling]
    -   [Logistic Regression]

## Data loading

```{r setup, message=FALSE}
options(repos = c(CRAN = "https://cloud.r-project.org"))
library(dplyr)
library(tidyr)
library(stringr)
library(formattable)
library(ggcorrplot)
suppressWarnings({
  library(ggplot2)
  library(lubridate)
  library(gridExtra)
})
library(ggcorrplot)
library(readr)
library(scales)
library(fastDummies)
library(plotly)
```

```{r}
train <- read_csv("train.csv")
test  <- read.csv("test.csv")
df    <- bind_rows(train, test)
```

## Preliminary Data Analysis

```{r}
cat("Shape of training dataframe: ", dim(train), "\n")
cat("Shape of testing dataframe: ", dim(test), "\n")

train <- train[!duplicated(train), ]
test <- test[!duplicated(test), ]

cat("Shape of training dataframe after removing duplicates: ", dim(train), "\n")
cat("Shape of testing dataframe after removing duplicates: ", dim(test), "\n")
```

```{r inspection Variable Inspection}
### Variable Inspection

cat("Names of columns: ", colnames(train), "\n")


```

We have 41 variables, no duplicates were detected. Overall, we have over
230 thousand observations in our training set. Let's check whether the
dataset has any missing values.

```{r}
total <- nrow(train)
missing_data <- train %>%
  summarise(across(everything(), ~sum(is.na(.)))) %>%
  pivot_longer(everything(), names_to = "column name", values_to = "Total missing") %>%
  mutate(`Percent missing` = (`Total missing` / total) * 100) %>%
  arrange(desc(`Total missing`))
print(missing_data)
```

We can see that more that 3% of the 'EMPLOYMENT_TYPE' variable's values
is missing. We will treat the NA values as not employed.

```{r}
print(unique(train$EMPLOYMENT_TYPE))
length(unique(train$EMPLOYMENT_TYPE))
```

Let's analyze the structure of the data set. We can see that most of the
variables are numeric. We see that 'AVERAGE_ACCT_AGE' and
'CREDIT_HISTORY_LENGHT' can be changed from characters to numbers.

```{r}
str(train)
```

```{r}
parse_age <- function(x) {
  years <- as.numeric(str_extract(x, "\\d+(?=yrs)"))
  months <- as.numeric(str_extract(x, "\\d+(?=mon)"))
  years[is.na(years)] <- 0
  months[is.na(months)] <- 0
  years + months / 12
}

train <- train %>%
  mutate(AVERAGE_ACCT_AGE = parse_age(AVERAGE_ACCT_AGE),
         CREDIT_HISTORY_LENGTH = parse_age(CREDIT_HISTORY_LENGTH))

test <- test %>%
  mutate(AVERAGE_ACCT_AGE = parse_age(AVERAGE_ACCT_AGE),
         CREDIT_HISTORY_LENGTH = parse_age(CREDIT_HISTORY_LENGTH))

```

Additionally, we changed the format of variables 'DATE_OF_BIRTH' and
'DISBURSAL_DATE' form object to date.

```{r}

train$DATE_OF_BIRTH <- as.Date(train$DATE_OF_BIRTH, format = "%d-%m-%Y")
test$DATE_OF_BIRTH  <- as.Date(test$DATE_OF_BIRTH,  format = "%d-%m-%Y")


train$DISBURSAL_DATE <- as.Date(train$DISBURSAL_DATE, format = "%d-%m-%Y")
test$DISBURSAL_DATE  <- as.Date(test$DISBURSAL_DATE,  format = "%d-%m-%Y")
```

Finally, we obtained the dataset shaped like this:

```{r}
str(train)
```

## Explanatory Data Analysis

Now we can proceed with the EDA. Let's start with

### Class distribution

We will analyze the distribution of the target variable 'LOAN_DEFAULT'.

```{r}
class_df <- train %>%
  group_by(LOAN_DEFAULT) %>%
  summarise(UNIQUEID_count = n()) %>%
  arrange(desc(UNIQUEID_count))

formattable(class_df, list( UNIQUEID_count = color_bar("lightgreen") ))
```

```{r}
colors <- c("0" = "deepskyblue", "1" = "deeppink")

ggplot(train, aes(x = factor(LOAN_DEFAULT), fill = factor(LOAN_DEFAULT))) +
  geom_bar() +
  scale_fill_manual(values = colors) +
  labs(title = "Class Distribution", x = "Loan Default", y = "Count") +
  theme_minimal()

count_default_0 <- sum(train$LOAN_DEFAULT == 0, na.rm = TRUE)
count_default_1 <- sum(train$LOAN_DEFAULT == 1, na.rm = TRUE)
total <- count_default_0 + count_default_1

percentage_0 <- (count_default_0 / total) * 100
percentage_1 <- (count_default_1 / total) * 100

cat(sprintf("%% of no defaults       : %.2f%%\n", percentage_0))
cat(sprintf("Number of no defaults  : %d\n", count_default_0))
cat(sprintf("%% of defaults          : %.2f%%\n", percentage_1))
cat(sprintf("Number of defaults     : %d\n", count_default_1))
```

Also, let's analyze the distribution between other categorical
variables, such as 'EMPLOYMENT_TYPE', 'MOBILENO_AVL_FLAG',
'AADHAR_FLAG', 'PAN_FLAG', 'VOTERID_FLAG', 'DRIVING_FLAG' and
'PASSPORT_FLAG'
**'EMPLOYMENT_TYPE'**
```{r}
train %>%
  group_by(EMPLOYMENT_TYPE, LOAN_DEFAULT) %>%
  summarise(count = n(), .groups = 'drop') %>%
  group_by(EMPLOYMENT_TYPE) %>%
  mutate(prop = count / sum(count)) %>%
  arrange(EMPLOYMENT_TYPE, LOAN_DEFAULT) %>%
  print(n = Inf)
```
**'MOBILENO_AVL_FLAG'**
```{r}
train %>%
  group_by(MOBILENO_AVL_FLAG, LOAN_DEFAULT) %>%
  summarise(count = n(), .groups = 'drop') %>%
  group_by(MOBILENO_AVL_FLAG) %>%
  mutate(percentage = count / sum(count)) %>%
  print()
```
**'AADHAR_FLAG'**
```{r}
train %>%
  group_by(AADHAR_FLAG, LOAN_DEFAULT) %>%
  summarise(count = n(), .groups = 'drop') %>%
  group_by(AADHAR_FLAG) %>%
  mutate(percentage = count / sum(count)) %>%
  print()
```
***'PAN_FLAG'**
```{r}
train %>%
  group_by(PAN_FLAG, LOAN_DEFAULT) %>%
  summarise(count = n(), .groups = 'drop') %>%
  group_by(PAN_FLAG) %>%
  mutate(percentage = count / sum(count)) %>%
  print()
```
**'VOTERID_FLAG'**
```{r}
train %>%
  group_by(VOTERID_FLAG, LOAN_DEFAULT) %>%
  summarise(count = n(), .groups = 'drop') %>%
  group_by(VOTERID_FLAG) %>%
  mutate(percentage = count / sum(count)) %>%
  print()
```
**'DRIVING_FLAG'**
```{r}
train %>%
  group_by(DRIVING_FLAG, LOAN_DEFAULT) %>%
  summarise(count = n(), .groups = 'drop') %>%
  group_by(DRIVING_FLAG) %>%
  mutate(percentage = count / sum(count)) %>%
  print()
```
**'PASSPORT_FLAG'**
```{r}
train %>%
  group_by(PASSPORT_FLAG, LOAN_DEFAULT) %>%
  summarise(count = n(), .groups = 'drop') %>%
  group_by(PASSPORT_FLAG) %>%
  mutate(percentage = count / sum(count)) %>%
  print()
```
**Combined**
```{r}
train %>%
  group_by(LOAN_DEFAULT, EMPLOYMENT_TYPE, AADHAR_FLAG, PAN_FLAG, DRIVING_FLAG, PASSPORT_FLAG, VOTERID_FLAG) %>%
  summarise(count = n(), .groups = 'drop') %>%
  arrange(desc(count)) %>%
  print()
```

We can observe that the distribution between defaulted and non-defaulted
client across all analyzed variables fluctuates around 21/79.

### Default vs. Disbursal date

```{r}
train$LOAN_DEFAULT <- as.factor(train$LOAN_DEFAULT)

ggplot(train, aes(x = DISBURSAL_DATE, fill = LOAN_DEFAULT)) +
  geom_histogram(data = subset(train, LOAN_DEFAULT == 1), 
                 bins = 50, alpha = 0.8, fill = "deeppink") +
  geom_histogram(data = subset(train, LOAN_DEFAULT == 0), 
                 bins = 50, alpha = 0.8, fill = "deepskyblue") +
  facet_wrap(~LOAN_DEFAULT, ncol = 1, scales = "free_y",
             labeller = as_labeller(c(`0` = "No default", `1` = "Default"))) +
  labs(x = "DISBURSAL DATE", y = "Number of Loans") +
  theme_bw() +
  theme(legend.position = "none")
```

### Outlier Treatment

First let's define a couple of useful functions that will help us
quickly perform univariate analysis.

```{r}
# Plot distribution of one feature

plot_distribution <- function(feature, color = "steelblue") {
ggplot(train, aes_string(x = feature)) + geom_histogram(aes(y =
..density..), fill = color, bins = 100, alpha = 0.7, na.rm = TRUE) +
geom_density(color = "black", size = 1, na.rm = TRUE) + labs(title =
paste("Distribution of", feature), x = feature, y = "Density") +
theme_minimal() }
```

```{r}
# Plot distribution of multiple features, with TARGET = 1/0 on the same graph

plot_bar_comp <- function(var, nrow = 2) {
  plot_list <- list()
  
  for (feature in var) {
    p <- ggplot(train, aes_string(x = feature)) +
      geom_bar(fill = "skyblue") +
      labs(x = feature, y = "Count plot") +
      theme_minimal(base_size = 12)
    plot_list[[length(plot_list) + 1]] <- p
  }
  
  ncol <- 2
  do.call(grid.arrange, c(plot_list, nrow = nrow, ncol = ncol))
}

```

```{r}
plot_distribution_comp <- function(data, variables, n_rows = 3, n_cols = 2) {
  plot_list <- list()
  
  for (var in variables) {
    # Check if variable has very large values that need scientific notation
    scientific <- max(data[[var]], na.rm = TRUE) > 1e6
    
    p <- ggplot(data, aes_string(x = var, color = "factor(LOAN_DEFAULT)", 
                                 fill = "factor(LOAN_DEFAULT)")) +
      geom_density(alpha = 0.2) +
      scale_color_manual(name = "",
                       values = c("0" = "blue", "1" = "red"),
                       labels = c("LOAN_DEFAULT = 0", "LOAN_DEFAULT = 1")) +
      scale_fill_manual(name = "",
                       values = c("0" = "blue", "1" = "red"),
                       labels = c("LOAN_DEFAULT = 0", "LOAN_DEFAULT = 1")) +
      labs(x = var, y = "Density plot") +
      theme_bw() +
      theme(panel.grid.major = element_line(color = "grey90"),
            panel.grid.minor = element_line(color = "grey90"),
            legend.position = "bottom",
            legend.box = "horizontal",
            plot.title = element_text(size = 11))
    
    # Use scientific notation for large value variables
    if (scientific) {
      p <- p + scale_x_continuous(labels = scientific_format())
    }
    
    plot_list[[length(plot_list) + 1]] <- p
  }
  
  # Arrange all plots in a grid
  grid.arrange(grobs = plot_list, nrow = n_rows, ncol = n_cols)
}
```

```{r}
# Box Plot for one feature

plot_box <- function(feature, color = "skyblue") { ggplot(train,
aes_string(y = feature)) + geom_boxplot(fill = color, outlier.color =
"red", na.rm = TRUE) + labs(title = paste("Box Plot of", feature), y =
feature) + theme_minimal() }
```

```{r}
# Bar Plot for one feature

plot_bar <- function(feature) { ggplot(train, aes_string(y = feature,
fill = "factor(LOAN_DEFAULT)")) + geom_bar(position = "dodge", color =
"black") + scale_fill_manual(values = c("0" = "skyblue", "1" = "pink"),
name = "LOAN_DEFAULT", labels = c("No Default", "Default")) + labs(title
= paste("Bar Plot of", feature, "by Loan Default"), y = feature, x =
"Count") + theme_minimal() + theme( axis.text.y = element_text(size =
10), plot.title = element_text(size = 14, face = "bold") ) }
```

Now, let's analyze important explanatory variable:
**'DISBURSED_AMOUNT'**.

```{r}
summary(train$DISBURSED_AMOUNT)

plot_distribution("DISBURSED_AMOUNT", "green")

plot_box("DISBURSED_AMOUNT", "green")

```

Based on the box plot, we can observe the presence of the outliers. We
will try two methods of dealing with outliers: replacing the outliers'
values with a sample mean and binning. But first, let's define functions
that will speed up the outlier detection process. We will create a
function that will calculate all necessary statistical values: mean,
lower and upper threshold.

```{r}
outlier_data <- function(df, feature) {
  # Number of observations
  obs <- length(df[[feature]])
  cat("No. of observations in column:", obs, "\n")
  
  # Descriptive statistics
  data_mean <- mean(df[[feature]], na.rm = TRUE)
  data_sd   <- sd(df[[feature]], na.rm = TRUE)
  cat(sprintf("Statistics: Mean = %.3f, Std dev = %.3f\n", data_mean, data_sd))
  
  # Thresholds for outliers, set as 3 standard deviations
  cut_off <- data_sd * 3
  lower <- data_mean - cut_off
  upper <- data_mean + cut_off
  
  # Outliers count
  outliers <- df[[feature]][df[[feature]] < lower | df[[feature]] > upper]
  cat("Identified outliers:", length(outliers), "\n")
  
  return(list(lower = lower, upper = upper, mean = data_mean))
}
```

Now, let's play with smoothing the outliers. We will create the function
that will impute the outstanding obseravtions.

```{r}
impute_outlier <- function(vec, lower, upper, mean_val) {
  sapply(vec, function(x) {
    if (is.na(x)) {
      return(NA)
    } else if (x <= lower || x >= upper) {
      return(mean_val)
    } else {
      return(x)
    }
  })
}
```

```{r}
disbursed_amount_stats <- outlier_data(train, 'DISBURSED_AMOUNT')
```

We manage to identify more that 3000 outliers. Now we will replace the
values with the mean.

```{r}
train$DISBURSED_AMOUNT_new <- impute_outlier(train$DISBURSED_AMOUNT, disbursed_amount_stats$lower, disbursed_amount_stats$upper, disbursed_amount_stats$mean)

# No. of observations after the imputation

cat("No. of observations in column: ", length(train$DISBURSED_AMOUNT_new), "\n")
```

Now let's try binning. Firstly, we have too divide our variable's range
into bins. We chose to divide it to 4 bins based on quantiles.

```{r}
bin_labels <- c("Low", "Medium", "High", "Extreme")

quantiles <- quantile(train$DISBURSED_AMOUNT, probs = c(0, 0.25, 0.5, 0.75, 1), na.rm = TRUE)

# Quantile distribution
train$DISBURSED_AMOUNT_bins <- cut(train$DISBURSED_AMOUNT,
                                   breaks = quantiles,
                                   include.lowest = TRUE,
                                   labels = bin_labels)

table(train$DISBURSED_AMOUNT_bins)

plot_bar("DISBURSED_AMOUNT_bins")
```

Now let's analyze another variable: **'ASSET_COST'**

```{r}
summary(train$ASSET_COST)
plot_distribution <- function(feature, color = "steelblue") {
  ggplot(train, aes_string(x = feature)) +
    geom_histogram(aes(y = ..density..), fill = color, bins = 100, alpha = 0.7, na.rm = TRUE) +
    geom_density(color = "black", size = 1, na.rm = TRUE) +
    labs(title = paste("Distribution of", feature), x = feature, y = "Density") +
    theme_minimal()
}
plot_distribution("ASSET_COST", "tomato")
plot_box("ASSET_COST", "tomato")
```

Again, we can notice the presence of the outliers. We can apply similar
approach as before.

Imputation

```{r}
asset_cost_stats <- outlier_data(train, 'ASSET_COST')
```

Almost 4500 outliers detected - let's try smoothing them out with mean

```{r}
train$ASSET_COST_new <- impute_outlier(train$ASSET_COST, asset_cost_stats$lower, asset_cost_stats$upper, asset_cost_stats$mean)

# No. of observations after the imputation

cat("No. of observations in column: ", length(train$ASSET_COST_new), "\n")
```

Binning

```{r}
quantiles <- quantile(train$ASSET_COST, probs = c(0, 0.25, 0.5, 0.75, 1), na.rm = TRUE)

#Quantile distribution
train$ASSET_COST_bins <- cut(train$ASSET_COST,
                                   breaks = quantiles,
                                   include.lowest = TRUE,
                                   labels = bin_labels)

table(train$ASSET_COST_bins)

plot_bar("ASSET_COST_bins")
```

**'LTV'**

```{r}
summary(train$LTV)
plot_distribution <- function(feature, color = "steelblue") {
  ggplot(train, aes_string(x = feature)) +
    geom_histogram(aes(y = ..density..), fill = color, bins = 100, alpha = 0.7, na.rm = TRUE) +
    geom_density(color = "black", size = 1, na.rm = TRUE) +
    labs(title = paste("Distribution of", feature), x = feature, y = "Density") +
    theme_minimal()
}
plot_distribution("LTV", "tomato")
plot_box("LTV", "tomato")
```

Imputation

```{r}
LTV_stats <- outlier_data(train, 'LTV')
```

```{r}
train$LTV_new <- impute_outlier(train$LTV, LTV_stats$lower, LTV_stats$upper, LTV_stats$mean)

# No. of observations after the imputation

cat("No. of observations in column: ", length(train$LTV_new), "\n")
```

Binning

```{r}
quantiles <- quantile(train$LTV, probs = c(0, 0.25, 0.5, 0.75, 1), na.rm = TRUE)

#Quantile distribution
train$LTV_bins <- cut(train$LTV,
                                   breaks = quantiles,
                                   include.lowest = TRUE,
                                   labels = bin_labels)

table(train$LTV_bins)

plot_bar("LTV_bins")
```

**'PERFORM_CNS_SCORE'**

```{r}
summary(train$PERFORM_CNS_SCORE)
plot_distribution <- function(feature, color = "steelblue") {
  ggplot(train, aes_string(x = feature)) +
    geom_histogram(aes(y = ..density..), fill = color, bins = 100, alpha = 0.7, na.rm = TRUE) +
    geom_density(color = "black", size = 1, na.rm = TRUE) +
    labs(title = paste("Distribution of", feature), x = feature, y = "Density") +
    theme_minimal()
}
plot_distribution("PERFORM_CNS_SCORE", "tomato")
plot_box("PERFORM_CNS_SCORE", "tomato")
```

Imputation

```{r}
perform_cns_score_stats <- outlier_data(train, 'PERFORM_CNS_SCORE')
```

```{r}
train$PERFORM_CNS_SCORE_new <- impute_outlier(train$PERFORM_CNS_SCORE, perform_cns_score_stats$lower, perform_cns_score_stats$upper, perform_cns_score_stats$mean)

# No. of observations after the imputation

cat("No. of observations in column: ", length(train$PERFORM_CNS_SCORE_new), "\n")
```

Binning

```{r}
bin_labels = c("No History",'Very Low', "Low" ,'Medium', 'High')
cut_bins = c(-1,10,150, 350, 650, 1000)

quantiles <- quantile(train$PERFORM_CNS_SCORE, probs = c(0, 0.25, 0.5, 0.75, 1), na.rm = TRUE)

#Quantile distribution
train$PERFORM_CNS_SCORE_bins <- cut(train$PERFORM_CNS_SCORE,
                                   breaks = cut_bins,
                                   include.lowest = TRUE,
                                   labels = bin_labels)

table(train$PERFORM_CNS_SCORE_bins)

plot_bar("PERFORM_CNS_SCORE_bins")
```

**'PERFORM_CNS_SCORE_DESCRIPTION'**

```{r}
train %>%
  group_by(PERFORM_CNS_SCORE_DESCRIPTION, PERFORM_CNS_SCORE_bins) %>%
  summarise(count = n(), .groups = "drop") %>%
  arrange(desc(count))

table(train$PERFORM_CNS_SCORE_DESCRIPTION)

gg <- train %>%
  group_by(PERFORM_CNS_SCORE_DESCRIPTION, LOAN_DEFAULT) %>%
  summarise(counts = n(), .groups = "drop") %>%
  group_by(PERFORM_CNS_SCORE_DESCRIPTION) %>%
  mutate(percentage = counts / sum(counts) * 100) %>%
  ungroup()

print(gg)
```

**'PRI_NO_OF_ACCTS'**

```{r}
summary(train$PRI_NO_OF_ACCTS)
plot_distribution <- function(feature, color = "steelblue") {
  ggplot(train, aes_string(x = feature)) +
    geom_histogram(aes(y = ..density..), fill = color, bins = 100, alpha = 0.7, na.rm = TRUE) +
    geom_density(color = "black", size = 1, na.rm = TRUE) +
    labs(title = paste("Distribution of", feature), x = feature, y = "Density") +
    theme_minimal()
}
plot_distribution("PRI_NO_OF_ACCTS", "tomato")
plot_box("PRI_NO_OF_ACCTS", "tomato")
```

Imputation

```{r}
pri_no_of_accts_stats <- outlier_data(train, 'PRI_NO_OF_ACCTS')
```

```{r}
train$PRI_NO_OF_ACCTS_new <- impute_outlier(train$PRI_NO_OF_ACCTS, pri_no_of_accts_stats$lower, pri_no_of_accts_stats$upper, pri_no_of_accts_stats$mean)

# No. of observations after the imputation

cat("No. of observations in column: ", length(train$PRI_NO_OF_ACCTS_new), "\n")
```

Binning

```{r}
bin_labels <- c("One", "More than One")
cut_bins <- c(-1, 1, 1000)

train$PRI_NO_OF_ACCTS_bins <- cut(train$PRI_NO_OF_ACCTS,
                                   breaks = cut_bins,
                                   include.lowest = TRUE,
                                   labels = bin_labels)

table(train$PRI_NO_OF_ACCTS_bins)

plot_bar("PRI_NO_OF_ACCTS_bins")
```

**'PRI_OVERDUE_ACCTS'**

```{r}
summary(train$PRI_OVERDUE_ACCTS)
plot_distribution <- function(feature, color = "steelblue") {
  ggplot(train, aes_string(x = feature)) +
    geom_histogram(aes(y = ..density..), fill = color, bins = 100, alpha = 0.7, na.rm = TRUE) +
    geom_density(color = "black", size = 1, na.rm = TRUE) +
    labs(title = paste("Distribution of", feature), x = feature, y = "Density") +
    theme_minimal()
}
plot_distribution("PRI_OVERDUE_ACCTS", "tomato")
plot_box("PRI_OVERDUE_ACCTS", "tomato")
```

Imputation

```{r}
pri_overdue_accts_stats <- outlier_data(train, 'PRI_OVERDUE_ACCTS')
```

```{r}
train$PRI_OVERDUE_ACCTS_new <- impute_outlier(train$PRI_OVERDUE_ACCTS, pri_overdue_accts_stats$lower, pri_overdue_accts_stats$upper, pri_overdue_accts_stats$mean)

# No. of observations after the imputation

cat("No. of observations in column: ", length(train$PRI_OVERDUE_ACCTS_new), "\n")
```

Binning

```{r}
bin_labels <- c("None", "One (or more)")
cut_bins <- c(-1, 0, 1000)

train$PRI_OVERDUE_ACCTS_bins <- cut(train$PRI_OVERDUE_ACCTS,
                                   breaks = cut_bins,
                                   include.lowest = TRUE,
                                   labels = bin_labels)

table(train$PPRI_OVERDUE_ACCTS_bins)

plot_bar("PRI_OVERDUE_ACCTS_bins")
```

Let's look into data with lesser importance

```{r}
var <- c("MOBILENO_AVL_FLAG", "AADHAR_FLAG", "PAN_FLAG", "VOTERID_FLAG", "PASSPORT_FLAG", "DRIVING_FLAG")
plot_bar_comp(var, nrow = 3)
```

## Univariate Analysis

**'EMPLOYMENT_TYPE'**

```{r}
ggplot(train, aes(x = EMPLOYMENT_TYPE, fill = factor(LOAN_DEFAULT))) +
geom_bar(position = "dodge", color = "black") + labs(title =
"EMPLOYMENT_TYPE vs LOAN_DEFAULT", x = "Employment Type", y = "Count",
fill = "Loan Default") + theme_minimal() + scale_fill_manual(values =
c("0" = "skyblue", "1" = "tomato"))
```

**Age is in days**

```{r}
now <- Sys.Date()
train$DATE_OF_BIRTH <- as.Date(train$DATE_OF_BIRTH, format = "%d-%m-%Y")
# If you want to handle possible future date-of-births (as in the commented-out Python line), you can do:
# train$DATE_OF_BIRTH <- ifelse(train$DATE_OF_BIRTH < now, train$DATE_OF_BIRTH, train$DATE_OF_BIRTH - lubridate::years(100))

# Calculate age in days
train$age <- as.numeric(difftime(now, train$DATE_OF_BIRTH, units = "days"))

# Print first few ages
print(head(train$age))
```

```{r}
train$disbursal_time <- as.numeric(difftime(now, train$DISBURSAL_DATE, units = "days"))
head(train$disbursal_time)
```

**'MANUFACTURER_ID'**

```{r}
ggplot(train, aes(x = factor(MANUFACTURER_ID), fill = factor(LOAN_DEFAULT))) +
  geom_bar(position = "dodge", color = "black") +
  labs(title = "MANUFACTURER_ID vs LOAN_DEFAULT",
       x = "MANUFACTURER_ID",
       y = "Count",
       fill = "Loan Default") +
  scale_fill_manual(values = c("0" = "skyblue", "1" = "tomato"),
                    labels = c("No Default", "Default")) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

**'BRANCH_ID'**

```{r}
ggplot(train, aes(x = factor(BRANCH_ID), fill = factor(LOAN_DEFAULT))) +
  geom_bar(position = "dodge", color = "black") +
  labs(title = "BRANCH_ID vs LOAN_DEFAULT",
       x = "BRANCH_ID",
       y = "Count",
       fill = "Loan Default") +
  scale_fill_manual(values = c("0" = "skyblue", "1" = "tomato"),
                    labels = c("No Default", "Default")) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

```{r}
var <- c("PRI_NO_OF_ACCTS_new", "PRI_ACTIVE_ACCTS", "PRI_OVERDUE_ACCTS_new",
         "PRI_CURRENT_BALANCE", "PRI_SANCTIONED_AMOUNT", "PRI_DISBURSED_AMOUNT")

plot_distribution_comp(train, var)
```

Let's see the new columns along with the less important continous
variables

```{r}
var <- c("SEC_NO_OF_ACCTS", "SEC_ACTIVE_ACCTS", "SEC_OVERDUE_ACCTS",
"SEC_CURRENT_BALANCE", "SEC_SANCTIONED_AMOUNT", "SEC_DISBURSED_AMOUNT")

plot_distribution_comp(train, var)
```

## Feature Selection

Now we will proceed with the feature selection. First, we will drop the
variables that won't be used in our model.

```{r}
train <- train %>%
  select(-DATE_OF_BIRTH, -STATE_ID, -EMPLOYEE_CODE_ID,
         -SUPPLIER_ID, -MANUFACTURER_ID, -CURRENT_PINCODE_ID, -BRANCH_ID)
```

Now, let's calucate the correlation matrix to see which features are
correlated with each other in order to decrease a number of used
variables.

```{r}
corr_cols <- c("PRI_ACTIVE_ACCTS", "PRI_CURRENT_BALANCE",
"PRI_SANCTIONED_AMOUNT", "PRI_DISBURSED_AMOUNT", "SEC_NO_OF_ACCTS",
"SEC_ACTIVE_ACCTS", "SEC_OVERDUE_ACCTS", "SEC_CURRENT_BALANCE",
"SEC_SANCTIONED_AMOUNT", "SEC_DISBURSED_AMOUNT", "PRI_NO_OF_ACCTS_new",
"PRI_OVERDUE_ACCTS_new")

corr_data <- train[, corr_cols]

corr_matrix <- cor(corr_data, use = "pairwise.complete.obs")

corr_melted <- melt(corr_matrix)

# Create interactive heatmap
plot_ly(data = corr_melted,
        x = ~Var1,
        y = ~Var2,
        z = ~value,
        zmin = -1,              
        zmax = 1,
        type = "heatmap",
        colors = colorRamp(c("steelblue", "white", "darkgreen")))
```

Not highly correlated with anyone: 'PRI_ACTIVE_ACCTS',
'PRI_CURRENT_BALANCE','PRI_SANCTIONED_AMOUNT',
'PRI_DISBURSED_AMOUNT','SEC_OVERDUE_ACCTS'.

'PRI_NO_OF_ACCTS_new','PRI_OVERDUE_ACCTS_new' are perfectly positively
correlated and hence we are keeping only one.

'SEC_NO_OF_ACCTS', 'SEC_ACTIVE_ACCTS' are highly positively correlated,
hence we are keeping only one.

'SEC_CURRENT_BALANCE', 'SEC_SANCTIONED_AMOUNT', 'SEC_DISBURSED_AMOUNT'
are highly positively correlated, hence we are keeping only one.

```{r}
train <- train %>%
  select(-PRI_OVERDUE_ACCTS_new, -SEC_ACTIVE_ACCTS, -SEC_SANCTIONED_AMOUNT, -SEC_DISBURSED_AMOUNT)
```

Now let's analyze other variables.

```{r}
corr_data <- train[, c('SEC_INSTAL_AMT',
'PERFORM_CNS_SCORE','NEW_ACCTS_IN_LAST_SIX_MONTHS',
'DELINQUENT_ACCTS_IN_LAST_SIX_MONTHS', 'AVERAGE_ACCT_AGE',
'CREDIT_HISTORY_LENGTH', 'NO_OF_INQUIRIES','age', 'disbursal_time')]

corr_matrix <- cor(corr_data, use = "pairwise.complete.obs")

corr_melted <- melt(corr_matrix)

# Create interactive heatmap
plot_ly(data = corr_melted,
        x = ~Var1,
        y = ~Var2,
        z = ~value,
        zmin = -1,            
        zmax = 1,
        type = "heatmap",
        colors = colorRamp(c("steelblue", "white", "darkgreen")))
```

'AVERAGE_ACCT_AGE', 'CREDIT_HISTORY_LENGTH' are highly positively
correlated and hence we are keeping only one.

```{r}
train <- train %>%
  select(-AVERAGE_ACCT_AGE)
```

```{r}
corr_data <- train[, c('PRI_ACTIVE_ACCTS', 'PRI_CURRENT_BALANCE',
'PRI_SANCTIONED_AMOUNT', 'PERFORM_CNS_SCORE', 'PRI_DISBURSED_AMOUNT',
'SEC_NO_OF_ACCTS', 'SEC_OVERDUE_ACCTS', 'SEC_CURRENT_BALANCE',
'PRIMARY_INSTAL_AMT', 'SEC_INSTAL_AMT', 'NEW_ACCTS_IN_LAST_SIX_MONTHS',
'DELINQUENT_ACCTS_IN_LAST_SIX_MONTHS', 'CREDIT_HISTORY_LENGTH',
'NO_OF_INQUIRIES', 'DISBURSED_AMOUNT_new', 'ASSET_COST_new', 'LTV_new',
'PRI_NO_OF_ACCTS_new', 'age', 'disbursal_time')]

corr_matrix <- cor(corr_data, use = "pairwise.complete.obs")

corr_melted <- melt(corr_matrix)

# Create interactive heatmap
plot_ly(data = corr_melted,
        x = ~Var1,
        y = ~Var2,
        z = ~value,
        zmin = -1,            
        zmax = 1,
        type = "heatmap",
        colors = colorRamp(c("steelblue", "white", "darkgreen")))
```

Based on the correlation matrix we decided to: Choose one out of
'PRI_SANCTIONED_AMOUNT', 'PRI_DISBURSED_AMOUNT' Choose one out of
'LTV_new', 'PRI_NO_OF_ACCTS_new' And eliminate
'NEW_ACCTS_IN_LAST_SIX_MONTHS

```{r}
train <- train %>%
  select(-PRI_SANCTIONED_AMOUNT,-PRI_NO_OF_ACCTS_new,-NEW_ACCTS_IN_LAST_SIX_MONTHS)
```

Now we will prepare our data sets. One will contain only continuous
variables, with the outliers treated with imputation. Other will also
contain binned variables.

**Continuous Variables**

```{r}
train_con <- train[, c('EMPLOYMENT_TYPE', 'MOBILENO_AVL_FLAG',
'AADHAR_FLAG', 'PAN_FLAG', 'VOTERID_FLAG', 'DRIVING_FLAG',
'PASSPORT_FLAG', 'PERFORM_CNS_SCORE', 'PERFORM_CNS_SCORE_DESCRIPTION',
'PRI_ACTIVE_ACCTS', 'PRI_CURRENT_BALANCE', 'PRI_DISBURSED_AMOUNT',
'SEC_NO_OF_ACCTS', 'SEC_OVERDUE_ACCTS', 'SEC_CURRENT_BALANCE',
'PRIMARY_INSTAL_AMT', 'SEC_INSTAL_AMT',
'DELINQUENT_ACCTS_IN_LAST_SIX_MONTHS', 'CREDIT_HISTORY_LENGTH',
'NO_OF_INQUIRIES', 'LOAN_DEFAULT', 'DISBURSED_AMOUNT_new',
'ASSET_COST_new', 'LTV_new', 'age', 'disbursal_time')]
```

**Binned Variables**

```{r}
train_bin <- train[, c('UNIQUEID', 'EMPLOYMENT_TYPE',
'MOBILENO_AVL_FLAG', 'AADHAR_FLAG', 'PAN_FLAG', 'VOTERID_FLAG',
'DRIVING_FLAG', 'PASSPORT_FLAG', 'PERFORM_CNS_SCORE',
'PERFORM_CNS_SCORE_DESCRIPTION', 'PRI_ACTIVE_ACCTS',
'PRI_CURRENT_BALANCE', 'PRI_DISBURSED_AMOUNT', 'SEC_NO_OF_ACCTS',
'SEC_OVERDUE_ACCTS', 'SEC_CURRENT_BALANCE', 'PRIMARY_INSTAL_AMT',
'SEC_INSTAL_AMT', 'DELINQUENT_ACCTS_IN_LAST_SIX_MONTHS',
'CREDIT_HISTORY_LENGTH', 'NO_OF_INQUIRIES', 'LOAN_DEFAULT',
'DISBURSED_AMOUNT_bins', 'ASSET_COST_bins', 'LTV_bins',
'PERFORM_CNS_SCORE_bins', 'PRI_NO_OF_ACCTS_bins',
'PRI_OVERDUE_ACCTS_bins', 'age', 'disbursal_time')]
```

## Standardization of data

Let's transform some of the variables for better modelling.

```{r}
scaleColumns <- function(df, cols_to_scale) { 
  for (col in cols_to_scale) { 
    df[[col]] <- scale(df[[col]]) 
  } 
  return(df) 
  }
```

```{r}
scaled_df <- scaleColumns(train_con, c('PERFORM_CNS_SCORE',
'PRI_ACTIVE_ACCTS', 'PRI_CURRENT_BALANCE', 'PRI_DISBURSED_AMOUNT',
'SEC_NO_OF_ACCTS', 'SEC_OVERDUE_ACCTS', 'SEC_CURRENT_BALANCE',
'PRIMARY_INSTAL_AMT', 'SEC_INSTAL_AMT',
'DELINQUENT_ACCTS_IN_LAST_SIX_MONTHS', 'CREDIT_HISTORY_LENGTH',
'NO_OF_INQUIRIES', 'DISBURSED_AMOUNT_new', 'ASSET_COST_new', 'LTV_new',
'age', 'disbursal_time'))

head(scaled_df)
```

## Dummy insertion

Let's turn the categorical variables into the dummy variables.

```{r}
train_dummy <- fastDummies::dummy_cols( scaled_df, remove_first_dummy = TRUE, remove_selected_columns = TRUE, ignore_na = TRUE)

head(train_dummy)
```

Finally, let's divide our modified dataset into a train and test set.

```{r}
library(caret) 
y <- train_dummy["LOAN_DEFAULT_1"]

X <- train_dummy[, setdiff(names(train_dummy), "LOAN_DEFAULT_1")]

dim(y)
```

```{r}
library(caTools)
set.seed(101) 
train_indices <- createDataPartition(y$LOAN_DEFAULT_1, p = 0.80, list = FALSE)

# Create training and testing datasets
X_train <- X[train_indices, ]
X_test <- X[-train_indices, ]
y_train <- y[train_indices, ]
y_test <- y[-train_indices, ]

k_fold <- trainControl(method = "cv", number = 10)
```

## Modeling

Now we can proceed to modeling. Firstly, we will define a couple of functions that will help us in the modeling process.

```{r}
# Confusion Matrix

plot_confusion_matrix <- function(cm, classes, normalize = FALSE, title = "Confusion Matrix") {
  cm_df <- as.data.frame(cm) 
  colnames(cm_df) <- c("True", "Predicted","Freq")
  if (normalize) { 
    cm_df <- cm_df %>% 
      group_by(True) %>% 
      mutate(Freq = Freq / sum(Freq)) %>% 
      ungroup() }
  
  max_val <- max(cm_df$Freq) 
  cm_df$text_color <- ifelse(cm_df$Freq >max_val / 2, "white", "black")
  
  ggplot(cm_df, aes(x = Predicted, y = True, fill = Freq)) +
    geom_tile(color = "white") + geom_text(aes(label = round(Freq, if(normalize) 2 else 0), color = text_color), size = 4) +
    scale_fill_gradient(low = "white", high = "blue") +
    scale_color_identity() + labs(title = title, x = "Predicted label", y ="True label") + theme_minimal() 
  }
```

```{r}
# Precision, Recall, F1 Score

show_metrics <- function(cm) { 
  cm <- as.matrix(cm)
  tp <- cm[1, 1] 
  fn <- cm[1, 0] 
  fp <- cm[0, 1] 
  tn <- cm[0, 0]
  
  precision <- tp / (tp + fp) 
  recall <- tp / (tp + fn) 
  f1_score <- 2 *((precision * recall) / (precision + recall))
  
  cat(sprintf("Precision = %.3f\n", precision)) 
  cat(sprintf("Recall =%.3f\n", recall)) 
  cat(sprintf("F1_score = %.3f\n", f1_score)) 
  }
```

```{r}
# Precision-recall curve

plot_precision_recall <- function(recall, precision) {
  df <- data.frame(recall = recall, precision = precision)
  
  ggplot(df, aes(x = recall, y = precision)) + geom_step(direction = "hv",alpha = 0.2, color = "blue") + 
    geom_area(stat = "step", alpha = 0.2,fill = "blue") + 
    geom_line(size = 1.2, color = "blue") + 
    xlim(0.0,1.0) + ylim(0.0, 1.05) + 
    labs(title = "Precision Recall Curve", x ="Recall", y = "Precision") + 
    theme_minimal() 
  }
```

```{r}
# ROC curve

plot_roc <- function(fpr, tpr) { 
  df <- data.frame(fpr = fpr, tpr =tpr)
  
  ggplot(df, aes(x = fpr, y = tpr)) + geom_line(color = "blue", size =1.2) + 
    geom_abline(slope = 1, intercept = 0, linetype = "dashed", color= "black", size = 1) + 
    xlim(0.0, 0.001) + ylim(0.0, 1.05) + 
    labs(title ="ROC Curve", x = "False Positive Rate", y = "True Positive Rate") +
    theme_minimal() 
  }
```

```{r}
#feature importance plot

plot_feature_importance <- function(model, predictors) { 
  tmp <- data.frame( Feature = predictors, Feature_importance = model$importance)
  tmp <- tmp[order(tmp$Feature_importance, decreasing = TRUE), ]
  
  ggplot(tmp, aes(x = reorder(Feature, Feature_importance), y =Feature_importance)) + 
    geom_bar(stat = "identity", fill = "steelblue") +
    coord_flip() + labs(title = "Features importance", x = "Feature", y ="Feature importance") + 
    theme_minimal() + theme(plot.title = element_text(size = 14)) 
  }
```

## Logistic Regression

```{r}
print(class(y_train))
```

```{r}
library(glmnet) 

if(is.list(y_train) && length(y_train) == 1) {
  y_train <- unlist(y_train)
}
logmodel <- glm(y_train ~ ., data = X_train, family = "binomial")

# Make predictions on test set
# For probabilities:
log_probs <- predict(logmodel, newdata = X_test, type = "response")
# For class predictions (equivalent to Python's predict):
logpred <- ifelse(log_probs > 0.5, 1, 0)

```

```{r}
# Print confusion matrix
if(is.data.frame(logpred)) {
  logpred <- as.vector(unlist(logpred))
}
if(is.list(y_test) && length(y_test) == 1) {
  y_test <- unlist(y_test)
}

conf_matrix <- confusionMatrix(factor(logpred, levels = c(0,1)), factor(y_test, levels = c(0,1)))
print(conf_matrix$table)

# Print accuracy (as a percentage)
accuracy <- conf_matrix$overall["Accuracy"]
print(paste0("Accuracy: ", round(accuracy * 100, 2), "%"))
```

```{r}
# Cross-validation
# Define k-fold cross-validation control
ctrl <- trainControl(method = "cv", number = 10)  # Assuming k_fold = 5 in your Python code

# Perform cross-validation
cv_model <- train(
  x = as.matrix(X_train),
  y = factor(y_train),
  method = "glm",
  family = "binomial",
  trControl = ctrl,
  metric = "Accuracy"
)

# Print cross-validated accuracy
LOGCV <- cv_model$results$Accuracy
print(paste0("Cross-validated accuracy: ", round(LOGCV * 100, 2), "%"))
```

```{r}
cm <- conf_matrix <- confusionMatrix(factor(logpred, levels = c(0,1)), factor(y_test, levels = c(0,1)))

# Extract and print the metrics (equivalent to the Python code)
# Accuracy
cat("Accuracy of model", cm$overall["Accuracy"], "\n")

# F1 Score
cat("F1 Score", cm$byClass["F1"], "\n")

# Recall Score
cat("Recall Score", cm$byClass["Sensitivity"], "\n")

# Balanced Accuracy Score 
cat("Balanced Accuracy Score", cm$byClass["Balanced Accuracy"], "\n")
```

```{r}
total <- nrow(X_train)
missing_data <- X_train %>%
  summarise(across(everything(), ~sum(is.na(.)))) %>%
  pivot_longer(everything(), names_to = "column name", values_to = "Total missing") %>%
  mutate(`Percent missing` = (`Total missing` / total) * 100) %>%
  arrange(desc(`Total missing`))
print(missing_data)
```
```{r}
X_train$`EMPLOYMENT_TYPE_Self employed`[is.na(X_train$`EMPLOYMENT_TYPE_Self employed`)] <- 0
X_test$`EMPLOYMENT_TYPE_Self employed`[is.na(X_test$`EMPLOYMENT_TYPE_Self employed`)] <- 0

```

## Random Forest
```{r}
library(randomForest)
library(caret)
library(RANN)

# Train the Random Forest model
# n_estimators=10 in Python is equivalent to ntree=10 in R
rfc <- randomForest(
  x = X_train,
  y = factor(y_train),  # Target variable should be a factor for classification
  ntree = 10            # Number of trees (equivalent to n_estimators in sklearn)
)

# Predict on test set
rfc_pred <- predict(rfc, X_test)
```

```{r}
# Ensure factors have same levels for confusion matrix
y_test_factor <- factor(y_test, levels = levels(rfc_pred))
  
# Create confusion matrix and print it
conf_matrix <- confusionMatrix(rfc_pred, y_test_factor)
print(conf_matrix$table)

# Print accuracy as percentage
print(paste0(round(conf_matrix$overall["Accuracy"] * 100, 2), "%"))
```
```{r}
print(class(X_train))
```
```{r}
# Cross-validation (for the logistic regression model, equivalent to the Python code)
# Assuming logmodel is already defined and k_fold value is known
set.seed(101)
ctrl <- trainControl(method = "cv", number = k_fold)

rf_cv_model <- train(
  x = X_train,             # Training features
  y = factor(y_train),     # Target variable (as factor for classification)
  method = "rf",           # Random Forest algorithm
  metric = "Accuracy",     # Primary evaluation metric
  trControl = ctrl,        # Cross-validation control settings
  ntree = 100,             # Number of trees
  tuneLength = 5           # Try 5 different mtry values
)

RFCV <- rf_cv_model$results$Accuracy
print(paste0("Cross-validated accuracy: ", round(RFCV * 100, 2), "%"))
```

```{r}
cm_rf <- confusionMatrix(factor(rfc_pred, levels=c(0,1)), factor(y_test, levels=c(0,1)), positive = "1")

# Print results (equivalent to the Python code)
cat("Accuracy of model", cm_rf$overall["Accuracy"], "\n")
cat("F1 Score", cm_rf$byClass["F1"], "\n")
cat("Recall Score", cm_rf$byClass["Sensitivity"], "\n")
cat("Balanced Accuracy Score", cm_rf$byClass["Balanced Accuracy"], "\n")
```

## Dealing with Imbalanced Data

## SMOTE 

SMOTE or Synthetic Minority Oversampling Technique is used to create synthetic data. SMOTE uses a nearest neighbors algorithm to generate new and synthetic data we can use for training our model.

```{r}
library(caret)     # For train-test split
library(DMwR2)     # For SMOTE implementation

# Setting up testing and training sets (equivalent to train_test_split)
set.seed(27)       # Set random seed for reproducibility (equivalent to random_state)
train_indices <- createDataPartition(y$LOAN_DEFAULT_1, p = 0.75, list = FALSE)  # 75% training (test_size=0.25)
X_train <- X[train_indices, ]
X_test <- X[-train_indices, ]
y_train <- y[train_indices,]
y_test <- y[-train_indices,]

X_train$`EMPLOYMENT_TYPE_Self employed`[is.na(X_train$`EMPLOYMENT_TYPE_Self employed`)] <- 0
X_test$`EMPLOYMENT_TYPE_Self employed`[is.na(X_test$`EMPLOYMENT_TYPE_Self employed`)] <- 0
```

```{r}
library(smotefamily)
# Apply SMOTE to handle class imbalance
# Combine features and target for SMOTE
train_data <- cbind(X_train, target = y_train)

# Apply SMOTE (equivalent to sm.fit_sample)
set.seed(27)       # Same random seed as in Python
smote_result <- SMOTE(X_train, y_train, K = 5, dup_size = 1)
X_train <- smote_result$data
y_train <- X_train$class
X_train$class <- NULL
```

**Stochastic Gradient Descent with Modified Huber Loss**
```{r}
#' SGD with Modified Huber Loss Implementation
#'
#' @param X Matrix or data frame of features
#' @param y Vector of binary labels (0 or 1)
#' @param learning_rate Initial learning rate
#' @param epochs Number of epochs (passes through the data)
#' @param batch_size Size of mini-batches
#' @param alpha L2 regularization parameter
#' @param shuffle Whether to shuffle the data at each epoch
#' @param random_seed Random seed for reproducibility
#' @param verbose Whether to print progress
#'
#' @return List containing weights, bias, and training history
sgd_modified_huber <- function(X, y, learning_rate = 0.01, epochs = 100, 
                               batch_size = 32, alpha = 0.0001, 
                               shuffle = TRUE, random_seed = NULL, 
                               verbose = TRUE) {
  # Set random seed if provided
  if (!is.null(random_seed)) {
    set.seed(random_seed)
  }
  
  # Ensure X is a matrix
  if (is.data.frame(X)) {
    X <- as.matrix(X)
  }
  
  # Initialize parameters
  n_samples <- nrow(X)
  n_features <- ncol(X)
  w <- rep(0, n_features)  # Weights initialized to zeros
  b <- 0                   # Bias term initialized to zero
  
  # Initialize training history
  history <- data.frame(epoch = integer(), loss = numeric())
  
  # Modified Huber loss gradient function
  modified_huber_gradient <- function(y_true, y_pred) {
    # Calculate margin = y * (w*x + b)
    margin <- y_true * y_pred
    
    # Calculate gradients based on the margin
    gradients <- rep(0, length(margin))
    
    # For margin > 1: gradient = 0
    # For -1 < margin < 1: gradient = (1 - margin) * (-y)
    # For margin < -1: gradient = (-y)
    
    case1 <- margin <= -1
    case2 <- margin > -1 & margin < 1
    
    gradients[case1] <- -y_true[case1]
    gradients[case2] <- -y_true[case2] * (1 - margin[case2])
    
    return(gradients)
  }
  
  # Shuffle function
  shuffle_data <- function(X, y) {
    idx <- sample(n_samples)
    return(list(X = X[idx,], y = y[idx]))
  }
  
  # Training loop
  for (epoch in 1:epochs) {
    epoch_loss <- 0
    
    # Shuffle data if requested
    if (shuffle) {
      shuffled <- shuffle_data(X, y)
      X_epoch <- shuffled$X
      y_epoch <- shuffled$y
    } else {
      X_epoch <- X
      y_epoch <- y
    }
    
    # Process mini-batches
    for (i in seq(1, n_samples, by = batch_size)) {
      # Get mini-batch
      end_idx <- min(i + batch_size - 1, n_samples)
      X_batch <- X_epoch[i:end_idx, , drop = FALSE]
      y_batch <- y_epoch[i:end_idx]
      
      # Convert y to {-1, 1} for modified Huber loss
      y_binary <- 2 * y_batch - 1
      
      # Forward pass
      scores <- X_batch %*% w + b
      
      # Compute gradients
      grads <- modified_huber_gradient(y_binary, scores)
      
      # Update parameters
      grad_w <- t(X_batch) %*% grads / length(y_batch) + alpha * w
      grad_b <- mean(grads)
      
      w <- w - learning_rate * grad_w
      b <- b - learning_rate * grad_b
      
      # Compute loss for monitoring
      loss_batch <- calculate_modified_huber_loss(y_binary, scores)
      epoch_loss <- epoch_loss + loss_batch * length(y_batch)
    }
    
    # Average loss for the epoch
    epoch_loss <- epoch_loss / n_samples
    
    # Save history
    history <- rbind(history, data.frame(epoch = epoch, loss = epoch_loss))
    
    # Print progress
    if (verbose && epoch %% 10 == 0) {
      cat(sprintf("Epoch %d/%d - Loss: %.4f\n", epoch, epochs, epoch_loss))
    }
  }
  
  # Return model parameters and history
  return(list(
    weights = w,
    bias = b,
    history = history
  ))
}

# Helper function to calculate modified Huber loss
calculate_modified_huber_loss <- function(y_true, scores) {
  margin <- y_true * scores
  
  # Calculate loss based on the margin
  losses <- rep(0, length(margin))
  
  # For margin > 1: loss = 0
  # For -1 < margin < 1: loss = (1 - margin)²
  # For margin < -1: loss = -4 * margin
  
  case1 <- margin <= -1
  case2 <- margin > -1 & margin < 1
  
  losses[case1] <- -4 * margin[case1]
  losses[case2] <- (1 - margin[case2])^2
  
  return(mean(losses))
}

# Prediction function
predict_sgd <- function(X, model, threshold = 0.5) {
  if (is.data.frame(X)) {
    X <- as.matrix(X)
  }
  
  # Calculate raw scores
  scores <- X %*% model$weights + model$bias
  
  # Convert scores to probabilities (simplified sigmoid)
  probs <- 1 / (1 + exp(-scores))
  
  # Return class predictions
  return(ifelse(probs > threshold, 1, 0))
}
```

```{r}
# Example usage:
# --------------------------------------
# Assuming you have X_train, y_train, X_test, y_test
y_train <- as.numeric(y_train)
# # Fit the model
model <- sgd_modified_huber(
   X = X_train,
   y = y_train,
   learning_rate = 0.01,
   epochs = 100,
   batch_size = 32,
   alpha = 0.0001,
   shuffle = TRUE,
   random_seed = 101,
   verbose = TRUE
 )
#
# # Make predictions
 y_pred <- predict_sgd(X_test, model)
#
```

```{r}
conf_matrix <- confusionMatrix(factor(y_pred, levels = c(0,1)), y_test_factor)
print(conf_matrix$table)
print(paste0(round(conf_matrix$overall["Accuracy"], 2) * 100, "%"))

# Extract and print the metrics (equivalent to the Python code)
# Accuracy
cat("Accuracy of model", conf_matrix$overall["Accuracy"], "\n")

# F1 Score
cat("F1 Score", conf_matrix$byClass["F1"], "\n")

# Recall Score
cat("Recall Score", conf_matrix$byClass["Sensitivity"], "\n")

# Balanced Accuracy Score 
cat("Balanced Accuracy Score", conf_matrix$byClass["Balanced Accuracy"], "\n")
```

**Decision Tree Classifier**
```{r}
# Load required packages
library(rpart)      # For decision tree
library(caret)      # For confusion matrix and cross-validation


# Train model (equivalent to DecisionTreeClassifier)
# Setting max_depth=10, min_samples_leaf=30, and random_state=101
set.seed(101)  # Equivalent to random_state in Python

# Train the decision tree
dtree <- rpart(
  formula = y_train ~ .,        # Formula: target depends on all features
  data = cbind(X_train, y_train = y_train),  # Combined data frame
  method = "class",             # For classification (use "anova" for regression)
  control = rpart.control(
    maxdepth = 10,              # Equivalent to max_depth
    minsplit = 60,              # Minimum number of observations in node before split (approx 2*min_samples_leaf)
    minbucket = 30,             # Equivalent to min_samples_leaf
    cp = 0.001                  # Complexity parameter (smaller values = larger tree)
  )
)

```

```{r}
# Predict on test set
dtree_pred <- predict(dtree, X_test, type = "class")

# Ensure predictions and actual values are factors with the same levels
y_test_factor <- factor(y_test$LOAN_DEFAULT_1)
dtree_pred_factor <- factor(dtree_pred, levels = levels(y_test_factor))

# Calculate confusion matrix
conf_matrix <- confusionMatrix(dtree_pred_factor, y_test_factor)
print(conf_matrix$table)

# Calculate accuracy
accuracy <- conf_matrix$overall["Accuracy"]
print(paste0(round(accuracy * 100, 2), "%"))
```

```{r}
# Extract and print the metrics (equivalent to the Python code)
# Accuracy
cat("Accuracy of model", conf_matrix$overall["Accuracy"], "\n")

# F1 Score
cat("F1 Score", conf_matrix$byClass["F1"], "\n")

# Recall Score
cat("Recall Score", conf_matrix$byClass["Sensitivity"], "\n")

# Balanced Accuracy Score 
cat("Balanced Accuracy Score", conf_matrix$byClass["Balanced Accuracy"], "\n")
```

**Random Forest Classifier**
```{r}
set.seed(42)  # For reproducibility, you can use any seed value

# Convert target to factor if it's a classification problem
if(!is.factor(y_train)) {
  y_train_factor <- factor(y_train)
} else {
  y_train_factor <- y_train
}

# Train the Random Forest model
rfc <- randomForest(
  x = X_train,              # Features
  y = y_train_factor,       # Target variable (must be a factor for classification)
  ntree = 10,               # Equivalent to n_estimators=10
  importance = TRUE         # Calculate variable importance
)

# Predict on test set
rfc_pred <- predict(rfc, X_test)
```

```{r}
rfc_pred_factor <- factor(rfc_pred, levels = levels(y_test_factor))
y_test_factor <- factor(y_test$LOAN_DEFAULT_1)

# Calculate confusion matrix
conf_matrix <- confusionMatrix(rfc_pred_factor, y_test_factor)
print(conf_matrix$table)

# Calculate accuracy and print as percentage
accuracy <- conf_matrix$overall["Accuracy"]
print(paste0("Accuracy: ", round(accuracy * 100, 2), "%"))

# Extract and print the metrics (equivalent to the Python code)
# Accuracy
cat("Accuracy of model", conf_matrix$overall["Accuracy"], "\n")

# F1 Score
cat("F1 Score", conf_matrix$byClass["F1"], "\n")

# Recall Score
cat("Recall Score", conf_matrix$byClass["Sensitivity"], "\n")

# Balanced Accuracy Score 
cat("Balanced Accuracy Score", conf_matrix$byClass["Balanced Accuracy"], "\n")
```
## Upsampling

Upsampling can be defined as adding more copies of the minority class. Upsampling can be a good choice when you don’t have a ton of data to work with. (Not a good choice here though)

```{r}
y <- train_dummy["LOAN_DEFAULT_1"]

X <- train_dummy[, setdiff(names(train_dummy), "LOAN_DEFAULT_1")]

set.seed(27)       # Set random seed for reproducibility (equivalent to random_state)
train_indices <- createDataPartition(y$LOAN_DEFAULT_1, p = 0.75, list = FALSE)  # 75% training (test_size=0.25)
X_train <- X[train_indices, ]
X_test <- X[-train_indices, ]
y_train <- y[train_indices,]
y_test <- y[-train_indices,]

X_train$`EMPLOYMENT_TYPE_Self employed`[is.na(X_train$`EMPLOYMENT_TYPE_Self employed`)] <- 0
X_test$`EMPLOYMENT_TYPE_Self employed`[is.na(X_test$`EMPLOYMENT_TYPE_Self employed`)] <- 0
```

```{r}
X <- cbind(X_train, LOAN_DEFAULT = y_train)

# Make sure X is a data frame (if it wasn't already)
X <- as.data.frame(X)

# Step 2: Separate minority and majority classes
# (equivalent to X[X.LOAN_DEFAULT==0] and X[X.LOAN_DEFAULT==1])
not_fraud <- X %>% filter(LOAN_DEFAULT_1 == 0)
fraud <- X %>% filter(LOAN_DEFAULT_1 == 1)

# Print class distribution
cat("Distribution before resampling:\n")
cat("Non-fraud samples:", nrow(not_fraud), "\n")
cat("Fraud samples:", nrow(fraud), "\n")
```


```{r}
# Load required libraries
library(dplyr)

# Set seed for reproducibility (equivalent to random_state=27)
set.seed(27)

# Upsample the minority class (fraud) with replacement
# Equivalent to: fraud_upsampled = resample(fraud, replace=True, n_samples=len(not_fraud), random_state=27)
fraud_upsampled <- fraud %>%
  slice_sample(n = nrow(not_fraud), replace = TRUE)

# Combine majority class and upsampled minority class
# Equivalent to: upsampled = pd.concat([not_fraud, fraud_upsampled])
upsampled <- bind_rows(not_fraud, fraud_upsampled)

# Check new class counts
# Equivalent to: upsampled.LOAN_DEFAULT.value_counts()
upsampled_counts <- upsampled %>%
  count(LOAN_DEFAULT_1)
print(upsampled_counts)

# Separate features and target
# Equivalent to:
# y_train = upsampled.LOAN_DEFAULT
# X_train = upsampled.drop('LOAN_DEFAULT', axis=1)
y_train <- upsampled$LOAN_DEFAULT_1
X_train <- upsampled %>% select(-LOAN_DEFAULT_1)

# Print dimensions to verify
cat("X_train dimensions:", dim(X_train)[1], "rows,", dim(X_train)[2], "columns\n")
cat("y_train length:", length(y_train), "\n")
```


**Decision Tree Classifier**
```{r}
set.seed(101)  # Equivalent to random_state in Python

# Train the decision tree
dtree <- rpart(
  formula = y_train ~ .,        # Formula: target depends on all features
  data = cbind(X_train, y_train = y_train),  # Combined data frame
  method = "class",             # For classification (use "anova" for regression)
  control = rpart.control(
    maxdepth = 10,              # Equivalent to max_depth
    minsplit = 60,              # Minimum number of observations in node before split (approx 2*min_samples_leaf)
    minbucket = 30,             # Equivalent to min_samples_leaf
    cp = 0.001                  # Complexity parameter (smaller values = larger tree)
  )
)

# Predict on test set
dtree_pred <- predict(dtree, X_test, type = "class")

# Ensure predictions and actual values are factors with the same levels
y_test_factor <- factor(y_test$LOAN_DEFAULT_1)
dtree_pred_factor <- factor(dtree_pred, levels = levels(y_test_factor))

# Calculate confusion matrix
conf_matrix <- confusionMatrix(dtree_pred_factor, y_test_factor)
print(conf_matrix$table)

# Calculate accuracy
accuracy <- conf_matrix$overall["Accuracy"]
print(paste0(round(accuracy * 100, 2), "%"))

# Extract and print the metrics (equivalent to the Python code)
# Accuracy
cat("Accuracy of model", conf_matrix$overall["Accuracy"], "\n")

# F1 Score
cat("F1 Score", conf_matrix$byClass["F1"], "\n")

# Recall Score
cat("Recall Score", conf_matrix$byClass["Sensitivity"], "\n")

# Balanced Accuracy Score 
cat("Balanced Accuracy Score", conf_matrix$byClass["Balanced Accuracy"], "\n")
```
**Stochastic Gradient Descent with Modified Huber Loss**
```{r}
# # Fit the model
model <- sgd_modified_huber(
   X = X_train,
   y = y_train,
   learning_rate = 0.01,
   epochs = 100,
   batch_size = 32,
   alpha = 0.0001,
   shuffle = TRUE,
   random_seed = 101,
   verbose = TRUE
 )
#
# # Make predictions
 y_pred <- predict_sgd(X_test, model)
 conf_matrix <- confusionMatrix(factor(y_pred, levels = c(0,1)), y_test_factor)
print(conf_matrix$table)
print(paste0(round(conf_matrix$overall["Accuracy"], 2) * 100, "%"))

# Extract and print the metrics (equivalent to the Python code)
# Accuracy
cat("Accuracy of model", conf_matrix$overall["Accuracy"], "\n")

# F1 Score
cat("F1 Score", conf_matrix$byClass["F1"], "\n")

# Recall Score
cat("Recall Score", conf_matrix$byClass["Sensitivity"], "\n")

# Balanced Accuracy Score 
cat("Balanced Accuracy Score", conf_matrix$byClass["Balanced Accuracy"], "\n")
```
**Random Forest Classifier**
```{r}
set.seed(42)  # For reproducibility, you can use any seed value

# Convert target to factor if it's a classification problem
if(!is.factor(y_train)) {
  y_train_factor <- factor(y_train)
} else {
  y_train_factor <- y_train
}

# Train the Random Forest model
rfc <- randomForest(
  x = X_train,              # Features
  y = y_train_factor,       # Target variable (must be a factor for classification)
  ntree = 10,               # Equivalent to n_estimators=10
  importance = TRUE         # Calculate variable importance
)

# Predict on test set
rfc_pred <- predict(rfc, X_test)

rfc_pred_factor <- factor(rfc_pred, levels = levels(y_test_factor))
y_test_factor <- factor(y_test$LOAN_DEFAULT_1)

# Calculate confusion matrix
conf_matrix <- confusionMatrix(rfc_pred_factor, y_test_factor)
print(conf_matrix$table)

# Calculate accuracy and print as percentage
accuracy <- conf_matrix$overall["Accuracy"]
print(paste0("Accuracy: ", round(accuracy * 100, 2), "%"))

# Extract and print the metrics (equivalent to the Python code)
# Accuracy
cat("Accuracy of model", conf_matrix$overall["Accuracy"], "\n")

# F1 Score
cat("F1 Score", conf_matrix$byClass["F1"], "\n")

# Recall Score
cat("Recall Score", conf_matrix$byClass["Sensitivity"], "\n")

# Balanced Accuracy Score 
cat("Balanced Accuracy Score", conf_matrix$byClass["Balanced Accuracy"], "\n")
```
## Downsampling

Undersampling can be defined as removing some observations of the majority class. Undersampling can be a good choice when you have a ton of data -think millions of rows. But a drawback is that we are removing information that may be valuable. This could lead to underfitting and poor generalization to the test set.

```{r}
y <- train_dummy["LOAN_DEFAULT_1"]

X <- train_dummy[, setdiff(names(train_dummy), "LOAN_DEFAULT_1")]

set.seed(27)       # Set random seed for reproducibility (equivalent to random_state)
train_indices <- createDataPartition(y$LOAN_DEFAULT_1, p = 0.75, list = FALSE)  # 75% training (test_size=0.25)
X_train <- X[train_indices, ]
X_test <- X[-train_indices, ]
y_train <- y[train_indices,]
y_test <- y[-train_indices,]

X_train$`EMPLOYMENT_TYPE_Self employed`[is.na(X_train$`EMPLOYMENT_TYPE_Self employed`)] <- 0
X_test$`EMPLOYMENT_TYPE_Self employed`[is.na(X_test$`EMPLOYMENT_TYPE_Self employed`)] <- 0

X <- cbind(X_train, LOAN_DEFAULT = y_train)

# Make sure X is a data frame (if it wasn't already)
X <- as.data.frame(X)

# Step 2: Separate minority and majority classes
# (equivalent to X[X.LOAN_DEFAULT==0] and X[X.LOAN_DEFAULT==1])
not_fraud <- X %>% filter(LOAN_DEFAULT_1 == 0)
fraud <- X %>% filter(LOAN_DEFAULT_1 == 1)
```

```{r}
set.seed(27)

# Upsample the minority class (fraud) with replacement
# Equivalent to: fraud_upsampled = resample(fraud, replace=True, n_samples=len(not_fraud), random_state=27)
fraud_downsampled <- fraud %>%
  slice_sample(n = nrow(not_fraud), replace = FALSE)

# Combine majority class and upsampled minority class
# Equivalent to: upsampled = pd.concat([not_fraud, fraud_upsampled])
downsampled <- bind_rows(not_fraud, fraud_downsampled)

# Check new class counts
# Equivalent to: upsampled.LOAN_DEFAULT.value_counts()
downsampled_counts <- downsampled %>%
  count(LOAN_DEFAULT_1)
print(downsampled_counts)

# Separate features and target
# Equivalent to:
# y_train = upsampled.LOAN_DEFAULT
# X_train = upsampled.drop('LOAN_DEFAULT', axis=1)
y_train <- downsampled$LOAN_DEFAULT_1
X_train <- downsampled %>% select(-LOAN_DEFAULT_1)
```
**Decision Tree Classifier**
```{r}
set.seed(101)  # Equivalent to random_state in Python

# Train the decision tree
dtree <- rpart(
  formula = y_train ~ .,        # Formula: target depends on all features
  data = cbind(X_train, y_train = y_train),  # Combined data frame
  method = "class",             # For classification (use "anova" for regression)
  control = rpart.control(
    maxdepth = 10,              # Equivalent to max_depth
    minsplit = 60,              # Minimum number of observations in node before split (approx 2*min_samples_leaf)
    minbucket = 30,             # Equivalent to min_samples_leaf
    cp = 0.001                  # Complexity parameter (smaller values = larger tree)
  )
)

# Predict on test set
dtree_pred <- predict(dtree, X_test, type = "class")

# Ensure predictions and actual values are factors with the same levels
y_test_factor <- factor(y_test$LOAN_DEFAULT_1)
dtree_pred_factor <- factor(dtree_pred, levels = levels(y_test_factor))

# Calculate confusion matrix
conf_matrix <- confusionMatrix(dtree_pred_factor, y_test_factor)
print(conf_matrix$table)

# Calculate accuracy
accuracy <- conf_matrix$overall["Accuracy"]
print(paste0(round(accuracy * 100, 2), "%"))

# Extract and print the metrics (equivalent to the Python code)
# Accuracy
cat("Accuracy of model", conf_matrix$overall["Accuracy"], "\n")

# F1 Score
cat("F1 Score", conf_matrix$byClass["F1"], "\n")

# Recall Score
cat("Recall Score", conf_matrix$byClass["Sensitivity"], "\n")

# Balanced Accuracy Score 
cat("Balanced Accuracy Score", conf_matrix$byClass["Balanced Accuracy"], "\n")
```

**Stochastic Gradient Descent with Modified Huber Loss**
```{r}
# # Fit the model
model <- sgd_modified_huber(
   X = X_train,
   y = y_train,
   learning_rate = 0.01,
   epochs = 100,
   batch_size = 32,
   alpha = 0.0001,
   shuffle = TRUE,
   random_seed = 101,
   verbose = TRUE
 )
#
# # Make predictions
 y_pred <- predict_sgd(X_test, model)
 conf_matrix <- confusionMatrix(factor(y_pred, levels = c(0,1)), y_test_factor)
print(conf_matrix$table)
print(paste0(round(conf_matrix$overall["Accuracy"], 2) * 100, "%"))

# Extract and print the metrics (equivalent to the Python code)
# Accuracy
cat("Accuracy of model", conf_matrix$overall["Accuracy"], "\n")

# F1 Score
cat("F1 Score", conf_matrix$byClass["F1"], "\n")

# Recall Score
cat("Recall Score", conf_matrix$byClass["Sensitivity"], "\n")

# Balanced Accuracy Score 
cat("Balanced Accuracy Score", conf_matrix$byClass["Balanced Accuracy"], "\n")
```

**Random Forest Classifier**
```{r}
set.seed(42)  # For reproducibility, you can use any seed value

# Convert target to factor if it's a classification problem
if(!is.factor(y_train)) {
  y_train_factor <- factor(y_train)
} else {
  y_train_factor <- y_train
}

# Train the Random Forest model
rfc <- randomForest(
  x = X_train,              # Features
  y = y_train_factor,       # Target variable (must be a factor for classification)
  ntree = 10,               # Equivalent to n_estimators=10
  importance = TRUE         # Calculate variable importance
)

# Predict on test set
rfc_pred <- predict(rfc, X_test)

rfc_pred_factor <- factor(rfc_pred, levels = levels(y_test_factor))
y_test_factor <- factor(y_test$LOAN_DEFAULT_1)

# Calculate confusion matrix
conf_matrix <- confusionMatrix(rfc_pred_factor, y_test_factor)
print(conf_matrix$table)

# Calculate accuracy and print as percentage
accuracy <- conf_matrix$overall["Accuracy"]
print(paste0("Accuracy: ", round(accuracy * 100, 2), "%"))

# Extract and print the metrics (equivalent to the Python code)
# Accuracy
cat("Accuracy of model", conf_matrix$overall["Accuracy"], "\n")

# F1 Score
cat("F1 Score", conf_matrix$byClass["F1"], "\n")

# Recall Score
cat("Recall Score", conf_matrix$byClass["Sensitivity"], "\n")

# Balanced Accuracy Score 
cat("Balanced Accuracy Score", conf_matrix$byClass["Balanced Accuracy"], "\n")
```

## PCA

```{r}
y <- train_dummy["LOAN_DEFAULT_1"]

X <- train_dummy[, setdiff(names(train_dummy), "LOAN_DEFAULT_1")]
X$`EMPLOYMENT_TYPE_Self employed`[is.na(X$`EMPLOYMENT_TYPE_Self employed`)] <- 0

set.seed(27)       # Set random seed for reproducibility (equivalent to random_state)
train_indices <- createDataPartition(y$LOAN_DEFAULT_1, p = 0.75, list = FALSE)  # 75% training (test_size=0.25)
X_train <- X[train_indices, ]
X_test <- X[-train_indices, ]
y_train <- y[train_indices,]
y_test <- y[-train_indices,]

X_train$`EMPLOYMENT_TYPE_Self employed`[is.na(X_train$`EMPLOYMENT_TYPE_Self employed`)] <- 0
X_test$`EMPLOYMENT_TYPE_Self employed`[is.na(X_test$`EMPLOYMENT_TYPE_Self employed`)] <- 0
```


```{r}
# Load required libraries
library(stats)  # Contains prcomp() for PCA

# Perform PCA
# In R, we typically use prcomp() or princomp() for PCA
# prcomp is generally preferred as it's based on SVD and more numerically stable

# Equivalent to: pca = PCA(); pca.fit(X)
pca_result <- prcomp(X_train, 
                     center = TRUE,   # Center the variables (equivalent to StandardScaler)
                     scale. = FALSE)  # By default, don't scale to unit variance

# Cumulative variance explained
cumulative_variance <- cumsum(variance_explained)
plot(cumulative_variance, 
     xlab = "Principal Component", 
     ylab = "Cumulative Proportion of Variance Explained",
     type = "b",
     main = "Cumulative Variance Explained")

```
```{r}
pca_result <- prcomp(X_train, 
                     center = TRUE,   # Center the variables (equivalent to StandardScaler)
                     scale. = FALSE,
                     rank. = 17)  # By default, don't scale to unit variance

# Print summary of the PCA
summary(pca_result)

# Visualize the proportion of variance explained by each component
variance_explained <- pca_result$sdev^2 / sum(pca_result$sdev^2)
plot(variance_explained, 
     xlab = "Principal Component", 
     ylab = "Proportion of Variance Explained",
     type = "b",
     main = "Scree Plot")

# Cumulative variance explained
cumulative_variance <- cumsum(variance_explained)
plot(cumulative_variance, 
     xlab = "Principal Component", 
     ylab = "Cumulative Proportion of Variance Explained",
     type = "b",
     main = "Cumulative Variance Explained")

# Access the principal components (equivalent to pca.components_ in Python)
loadings <- pca_result$rotation

# Access the transformed data (equivalent to pca.transform(X) in Python)
X_train_PCA <- as.data.frame(pca_result$x)
```

**Decision Tree Classifier**
```{r}
set.seed(101)  # Equivalent to random_state in Python

# Train the decision tree
dtree <- rpart(
  formula = y_train ~ .,        # Formula: target depends on all features
  data = cbind(X_train_PCA, y_train = y_train),  # Combined data frame
  method = "class",             # For classification (use "anova" for regression)
  control = rpart.control(
    maxdepth = 10,              # Equivalent to max_depth
    minsplit = 60,              # Minimum number of observations in node before split (approx 2*min_samples_leaf)
    minbucket = 30,             # Equivalent to min_samples_leaf
    cp = 0.001                  # Complexity parameter (smaller values = larger tree)
  )
)

# Predict on test set
X_test_PCA <- predict(pca_result, newdata = X_test)
X_test_PCA <- as.data.frame(X_test_PCA)

dtree_pred <- predict(dtree, X_test_PCA, type = "class")

# Ensure predictions and actual values are factors with the same levels
y_test_factor <- factor(y_test$LOAN_DEFAULT_1)
dtree_pred_factor <- factor(dtree_pred, levels = levels(y_test_factor))

# Calculate confusion matrix
conf_matrix <- confusionMatrix(dtree_pred_factor, y_test_factor)
print(conf_matrix$table)

# Calculate accuracy
accuracy <- conf_matrix$overall["Accuracy"]
print(paste0(round(accuracy * 100, 2), "%"))

# Extract and print the metrics (equivalent to the Python code)
# Accuracy
cat("Accuracy of model", conf_matrix$overall["Accuracy"], "\n")

# F1 Score
cat("F1 Score", conf_matrix$byClass["F1"], "\n")

# Recall Score
cat("Recall Score", conf_matrix$byClass["Sensitivity"], "\n")

# Balanced Accuracy Score 
cat("Balanced Accuracy Score", conf_matrix$byClass["Balanced Accuracy"], "\n")
```





